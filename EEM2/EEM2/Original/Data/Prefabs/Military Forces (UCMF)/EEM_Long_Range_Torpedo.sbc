<?xml version="1.0"?>
<Definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Prefabs>
    <Prefab xsi:type="MyObjectBuilder_PrefabDefinition">
      <Id Type="MyObjectBuilder_PrefabDefinition" Subtype="EEM_Long_Range_Torpedo" />
      <CubeGrids>
        <CubeGrid>
          <SubtypeName />
          <EntityId>123929224621855608</EntityId>
          <PersistentFlags>CastShadows InScene</PersistentFlags>
          <PositionAndOrientation>
            <Position x="293.683841712862" y="-328.63077903601334" z="98.688506807155136" />
            <Forward x="0.477188438" y="0.598667562" z="-0.6433416" />
            <Up x="-0.8215645" y="0.0440261029" z="-0.5684133" />
            <Orientation>
              <X>0.0128985476</X>
              <Y>-0.4220934</Y>
              <Z>0.6912456</Z>
              <W>0.586387455</W>
            </Orientation>
          </PositionAndOrientation>
          <GridSizeEnum>Large</GridSizeEnum>
          <CubeBlocks>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_RemoteControl">
              <SubtypeName>LargeBlockRemoteControl</SubtypeName>
              <EntityId>79666765106361386</EntityId>
              <Min x="0" y="2" z="2" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <UseSingleWeaponMode>false</UseSingleWeaponMode>
              <ControlWheels>true</ControlWheels>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </Toolbar>
              <SelectedGunId xsi:nil="true" />
              <IsMainCockpit>false</IsMainCockpit>
              <HorizonIndicatorEnabled>true</HorizonIndicatorEnabled>
              <BuildToolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots />
              </BuildToolbar>
              <PreviousControlledEntityId xsi:nil="true" />
              <AutoPilotEnabled>false</AutoPilotEnabled>
              <FlightMode>0</FlightMode>
              <BindedCamera>0</BindedCamera>
              <CurrentWaypointIndex>-1</CurrentWaypointIndex>
              <Waypoints />
              <Direction>0</Direction>
              <DockingModeEnabled>false</DockingModeEnabled>
              <CollisionAvoidance>false</CollisionAvoidance>
              <Coords />
              <Names />
              <WaypointThresholdDistance>0</WaypointThresholdDistance>
              <IsMainRemoteControl>false</IsMainRemoteControl>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Warhead">
              <SubtypeName>LargeWarhead</SubtypeName>
              <EntityId>73226426850614027</EntityId>
              <Min x="0" y="2" z="1" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <CustomName>Warhead 1</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <CountdownMs>1233</CountdownMs>
              <IsArmed>true</IsArmed>
              <IsCountingDown>false</IsCountingDown>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_TimerBlock">
              <SubtypeName>TimerBlockLarge</SubtypeName>
              <EntityId>86959529935296090</EntityId>
              <Min x="0" y="2" z="3" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <CustomName>Timer Loop</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>Start</Action>
                      <BlockEntityId>86959529935296090</BlockEntityId>
                    </Data>
                  </Slot>
                  <Slot>
                    <Index>1</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>TriggerNow</Action>
                      <BlockEntityId>86959529935296090</BlockEntityId>
                    </Data>
                  </Slot>
                  <Slot>
                    <Index>2</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalBlock">
                      <Action>RunWithDefaultArgument</Action>
                      <BlockEntityId>131661352107717645</BlockEntityId>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <JustTriggered>true</JustTriggered>
              <Delay>1000</Delay>
              <CurrentTime>0</CurrentTime>
              <IsCountingDown>false</IsCountingDown>
              <Silent>true</Silent>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_MyProgrammableBlock">
              <SubtypeName>LargeProgrammableBlock</SubtypeName>
              <EntityId>131661352107717645</EntityId>
              <Min x="0" y="2" z="4" />
              <BlockOrientation Forward="Down" Up="Backward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <CustomName>Program Homing AI</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Program>//----- This Is An NPC Only Script -----

//Type of block to disconnect missile from launching ship: 0 = Merge Block, 1 = Rotor, 2 = Connector, 3 = Merge Block And Any Locked Connectors, 4 = Rotor And Any Locked Connectors, 99 = No detach required
int missileDetachPortType = 99;

//Spin Missile By This RPM After Launch Clearance
int spinAmount = 0;

//Whether to perform a vertical takeoff for the launching procedure
bool verticalTakeoff = false;

//Whether to average out the target direction when calculating lead to mitigate impulse jammers
bool antiJamUseAverage = true;

//------------------------------ Reference Block Name Configuration ------------------------------

//By default all gyroscopes, thrusters and merge blocks will be considered for use. Setting a value here limits the script to use specific set of blocks
const string strGyroscopesPrefix = "";
const string strThrustersPrefix = "";
const string strDetachPort = "";
const string strDirectionRefBlock = "";
const string strLockOnSensor = "R_SENSOR";

//For debugging purposes
const string strStatusDisplayPrefix = "&lt;D&gt;";

//------------------------------ Missile Handling Configuration ------------------------------

double driftVectorReduction = 1.5;
double launchSeconds = 1;

//By default, script will determine whether to use these parameters. Setting a value forces script to use it
bool? boolDrift = null;
bool? boolLeadTarget = null;
bool? boolNaturalDampener = null;

//------------------------------ Above Is User Configuration Section. This Section Is For PID Tuning ------------------------------

const double DEF_SMALL_GRID_P = 300;                    //The default proportional gain of small grid gyroscopes
const double DEF_SMALL_GRID_I = 0.1;                    //The default integral gain of small grid gyroscopes
const double DEF_SMALL_GRID_D = 100;                    //The default derivative gain of small grid gyroscopes

const double DEF_BIG_GRID_P = 50;                       //The default proportional gain of large grid gyroscopes
const double DEF_BIG_GRID_I = 0.5;                      //The default integral gain of large grid gyroscopes
const double DEF_BIG_GRID_D = 4;                        //The default derivative gain of large grid gyroscopes

bool useDefaultPIDValues = true;                        //Whether to use predefined PID values based on detected grid size

double AIM_P = 0;                                       //The proportional gain of the gyroscope turning (Set useDefaultPIDValues to true to use default values)
double AIM_I = 0;                                       //The integral gain of the gyroscope turning (Set useDefaultPIDValues to true to use default values)
double AIM_D = 0;                                       //The derivative gain of the gyroscope turning (Set useDefaultPIDValues to true to use default values)
double AIM_LIMIT = 60;                                  //Limit value of both yaw and pitch combined

double INTEGRAL_WINDUP_LIMIT = 0;                       //Integral value limit to minimize integral windup. Zero means no limit

//------------------------------ Script Parameters Configuration ------------------------------

const int MERGE_SEPARATE_WAIT_THRESHOLD = 60;
const int ANTI_JAM_AVERAGE_ARRAY_SIZE = 6;

bool outputMissileStatus = false;

//------------------------------ Below Is Main Script Body ------------------------------

IMyRemoteControl remoteControl = null;
IMyTerminalBlock refForwardBlock = null;
IMyTerminalBlock refDownwardBlock = null;
IMySensorBlock lockOnSensor = null;
IMyTerminalBlock statusDisplay = null;

List&lt;IMyTerminalBlock&gt; gyroscopes = null;
string[] gyroYawField = null;
string[] gyroPitchField = null;
string[] gyroRollField = null;
float[] gyroYawFactor = null;
float[] gyroPitchFactor = null;
float[] gyroRollFactor = null;

List&lt;IMyTerminalBlock&gt; thrusters = null;
float[] thrustValues = null;

List&lt;IMyTerminalBlock&gt; launchThrusters = null;

MatrixD refWorldMatrix = default(MatrixD);
MatrixD refLookAtMatrix = default(MatrixD);
bool refForwardReverse = false;

Vector3D naturalGravity = new Vector3D();
double naturalGravityLength = 0;

Vector3D driftVector = new Vector3D();
double speed = 0;

Vector3D targetPosition = new Vector3D();
Vector3D lastTargetPosition = new Vector3D();

bool targetPositionSet = false;
int lastTargetPositionClock = 0;

Vector3D targetVector = new Vector3D();
double distToTarget = 0;

Vector3D targetDirection = new Vector3D();
double targetSpeed = 0;

int avgTargetDirectionIndex = 0;
Vector3D[] avgTargetDirectionArr = null;
Vector3D avgTargetDirectionSum = new Vector3D();

double targetYawAngle = 0;
double targetPitchAngle = 0;
double targetRollAngle = 0;

double lastYawError = 0;
double lastYawIntegral = 0;
double lastPitchError = 0;
double lastPitchIntegral = 0;
double lastRollError = 0;
double lastRollIntegral = 0;

int subCounter = 0;
int subMode = 0;
int mode = 0;
int clock = 0;
bool init = false;

IMyTerminalBlock detachBlockLocal = null;
IMyTerminalBlock detachBlockRemote = null;

string nameMatcher = "";

Random rnd = new Random();

const double RPM_FACTOR = 1800 / Math.PI;
const double ACOS_FACTOR = 180 / Math.PI;
const float GYRO_FACTOR = (float)(Math.PI / 30);

Vector3D Y_VECTOR = new Vector3D(0, -1, 0);
Vector3D Z_VECTOR = new Vector3D(0, 0, -1);
Vector3D POINT_ZERO = new Vector3D(0, 0, 0);

void Main(string arguments)
{
    //---------- Initialization And General Controls ----------

    if (!init)
    {
        if (subMode == 0)       //Check for configuration command
        {
            subMode = 1;

            if (arguments != null &amp;&amp; arguments.Length &gt; 0)
            {
                ProcessConfigurationCommand(arguments);
                return;
            }
        }

        if (subMode == 1)       //Missile still on launching ship's grid
        {
            if (!DetachFromGrid())
            {
                throw new Exception("--- Initialization Failed ---");
            }

            subCounter = 0;
            subMode = (missileDetachPortType == 99 ? 3 : 2);
            return;
        }
        else if (subMode == 2)  //Missile waiting for successful detachment from launching ship
        {
            if (detachBlockLocal == null || detachBlockRemote == null)
            {
                subMode = 3;
                return;
            }
            else if (detachBlockLocal.CubeGrid != detachBlockRemote.CubeGrid)
            {
                subMode = 3;
                return;
            }
            else
            {
                subCounter++;

                if (subCounter &gt;= MERGE_SEPARATE_WAIT_THRESHOLD)
                {
                    Echo("Error: Missile detach failed.");
                    throw new Exception("--- Initialization Failed ---");
                }

                return;
            }
        }
        else if (subMode == 3)  //Missile successfully detached and currently initializing
        {
            if (missileDetachPortType == 3 || missileDetachPortType == 4)
            {
                DetachLockedConnectors();
            }

            if (!InitMissileBlocks())
            {
                throw new Exception("--- Initialization Failed ---");
            }
        }

        if (antiJamUseAverage)
        {
            avgTargetDirectionArr = new Vector3D[ANTI_JAM_AVERAGE_ARRAY_SIZE];
            avgTargetDirectionIndex = 0;
        }

        subCounter = (int)(launchSeconds * 60);
        FireThrusters(verticalTakeoff ? launchThrusters : thrusters, true);

        subMode = 0;
        mode = 1;
        clock = 0;

        init = true;
        return;
    }

    //---------- Modes And Controls ----------

    clock += 1;

    CalculateParameters();

    if (mode == 1)          //Launching
    {
        if (subCounter &gt; 0)
        {
            subCounter--;
        }
        else
        {
            if (verticalTakeoff)
            {
                FireThrusters(launchThrusters, false);
                FireThrusters(thrusters, true);
            }

            SetGyroOverride(true);

            if (spinAmount &gt; 0)
            {
                SetGyroRoll(spinAmount);
            }

            lastTargetPosition = targetPosition = GetFlyStraightVector();

            subCounter = 0;
            subMode = 0;
            mode = 90;
        }
    }
    else if (mode == 90)    //Evil NPC Mode
    {
        targetPositionSet = remoteControl.GetNearestPlayer(out targetPosition);

        CalculateTargetParameters();
        AimAtTarget();

        if (boolNaturalDampener == true)
        {
            AimAtNaturalGravity();
        }
    }

    if (statusDisplay != null)
    {
        if (mode == 0)
        {
            DisplayStatus("Idle");
        }
        else if (mode == 1)
        {
            DisplayStatus("Launching");
        }
        else if (mode == 20)
        {
            DisplayStatus("Sensor: [" + Math.Round(targetPosition.GetDim(0), 2) + "," + Math.Round(targetPosition.GetDim(1), 2) + "," + Math.Round(targetPosition.GetDim(2), 2) + "]");
        }
        else if (mode == 90)
        {
            DisplayStatus("Aim: [" + Math.Round(targetPosition.GetDim(0), 2) + "," + Math.Round(targetPosition.GetDim(1), 2) + "," + Math.Round(targetPosition.GetDim(2), 2) + "]");
        }
        else
        {
            DisplayStatus("-");
        }
    }

    if (outputMissileStatus)
    {
        string statusCode;
        switch (mode)
        {
            case 0:
                statusCode = "-";
                break;
            case 1:
                statusCode = "F";
                break;
            case 20:
                statusCode = "S";
                break;
            case 90:
                statusCode = "L";
                break;
            default:
                statusCode = "-";
                break;
        }
        Echo("ST:" + mode + ":" + subMode + ":" + subCounter + ":" + clock + ":" + statusCode + ":" +
            Math.Round(targetPosition.GetDim(0), 5) + ":" + Math.Round(targetPosition.GetDim(1), 5) + ":" + Math.Round(targetPosition.GetDim(2), 5) + ":" +
            0 + ":");
    }
}

//------------------------------ Miscellaneous Methods ------------------------------

void DisplayStatus(string statusMsg)
{
    if (statusDisplay != null)
    {
        statusDisplay.SetCustomName(strStatusDisplayPrefix + " Mode: " + mode + ", " + statusMsg);
    }
}

Vector3D GetMissileMidPoint()
{
    return (Me.CubeGrid.GridIntegerToWorld(Me.CubeGrid.Min) + Me.CubeGrid.GridIntegerToWorld(Me.CubeGrid.Max)) / 2;
}

Vector3D GetFlyStraightVector()
{
    return (driftVector * 1000) + remoteControl.GetPosition();
}

//------------------------------ Missile And Target Information Methods ------------------------------

void CalculateParameters()
{
    //---------- Calculate Missile Related Variables ----------

    refWorldMatrix = refForwardBlock.WorldMatrix;
    refLookAtMatrix = MatrixD.CreateLookAt(POINT_ZERO, (refForwardReverse ? refWorldMatrix.Backward : refWorldMatrix.Forward), refWorldMatrix.Up);

    driftVector = remoteControl.GetShipVelocities().LinearVelocity;
    speed = driftVector.Length();

    naturalGravity = remoteControl.GetNaturalGravity();
    naturalGravityLength = naturalGravity.Length();
    naturalGravity = (naturalGravityLength &gt; 0 ? naturalGravity / naturalGravityLength : POINT_ZERO);
}

void CalculateTargetParameters()
{
    //---------- Calculate Target Parameters ----------

    if (boolLeadTarget == true)
    {
        if (targetPositionSet)
        {
            targetDirection = targetPosition - lastTargetPosition;
            if (antiJamUseAverage)
            {
                avgTargetDirectionSum -= avgTargetDirectionArr[avgTargetDirectionIndex];
                avgTargetDirectionArr[avgTargetDirectionIndex] = targetDirection;
                avgTargetDirectionSum += avgTargetDirectionArr[avgTargetDirectionIndex];
                avgTargetDirectionIndex++;
                if (avgTargetDirectionIndex &gt;= avgTargetDirectionArr.Length)
                {
                    avgTargetDirectionIndex = 0;
                }
                targetDirection = avgTargetDirectionSum / avgTargetDirectionArr.Length;
            }
            targetSpeed = targetDirection.Length();

            if (targetSpeed &gt; 0)
            {
                targetDirection = targetDirection / targetSpeed;
                targetSpeed = targetSpeed * 60 / (clock - lastTargetPositionClock);
            }

            lastTargetPosition = targetPosition;
            lastTargetPositionClock = clock;

            targetPositionSet = false;
        }
        else
        {
            targetPosition = lastTargetPosition + ((targetDirection * targetSpeed) / 60 * (clock - lastTargetPositionClock));
        }

        if (targetSpeed &gt; 0)
        {
            Vector3D aimPosition = ComputeIntersectionPoint(targetDirection, targetPosition, targetSpeed, remoteControl.GetPosition(), speed);
            if (!Double.IsNaN(aimPosition.Sum))
            {
                targetPosition = aimPosition;
            }
        }
    }

    targetVector = targetPosition - remoteControl.GetPosition();
    distToTarget = targetVector.Length();
    targetVector = targetVector / distToTarget;

    if (boolDrift == true &amp;&amp; speed &gt;= 5)
    {
        targetVector = (targetVector * speed) - (driftVector / driftVectorReduction);
        targetVector.Normalize();
    }

    targetVector = Vector3D.TransformNormal(targetVector, refLookAtMatrix);
    targetVector.Normalize();

    if (Double.IsNaN(targetVector.Sum))
    {
        targetVector = new Vector3D(Z_VECTOR);
    }
}

Vector3D CalculateTurretViewVector(IMyLargeTurretBase turret)
{
    Vector3D direction;
    Vector3D.CreateFromAzimuthAndElevation(turret.Azimuth, turret.Elevation, out direction);

    return Vector3D.TransformNormal(direction, turret.WorldMatrix);
}

//------------------------------ Missile Lock-On And Leading Methods ------------------------------

Vector3D ComputeIntersectionPoint(Vector3D targetDirection, Vector3D targetLocation, double targetSpeed, Vector3D currentLocation, double currentSpeed)
{
    //---------- Calculate Impact Point ----------

    //targetDirection Must Be Normalized
    double a = (targetSpeed * targetSpeed) - (currentSpeed * currentSpeed);
    double b = (2 * targetDirection.Dot(targetLocation - currentLocation) * targetSpeed);
    double c = (targetLocation - currentLocation).LengthSquared();

    double t;

    if (a == 0)
    {
        t = -c / a;
    }
    else
    {
        //Use Formula To Find Root: t = ( -b +- sqrt(b^2 - 4ac) ) / 2a
        double u = (b * b) - (4 * a * c);
        if (u &lt;= 0)
        {
            //Root Cannot Be Found. Target Unreachable
            return new Vector3D(Double.NaN, Double.NaN, Double.NaN);
        }
        u = Math.Sqrt(u);

        double t1 = (-b + u) / (2 * a);
        double t2 = (-b - u) / (2 * a);

        t = (t1 &gt; 0 ? (t2 &gt; 0 ? (t1 &lt; t2 ? t1 : t2) : t1) : t2);
    }

    if (t &lt; 0)
    {
        return new Vector3D(Double.NaN, Double.NaN, Double.NaN);
    }
    else
    {
        return targetLocation + (targetDirection * targetSpeed * t);
    }
}

//------------------------------ Missile Aiming Methods ------------------------------

int GetMultiplierSign(double value)
{
    return (value &lt; 0 ? -1 : 1);
}

void AimAtTarget()
{
    //---------- Activate Gyroscopes To Turn Towards Target ----------

    Vector3D yawVector = new Vector3D(targetVector.GetDim(0), 0, targetVector.GetDim(2));
    Vector3D pitchVector = new Vector3D(0, targetVector.GetDim(1), targetVector.GetDim(2));
    yawVector.Normalize();
    pitchVector.Normalize();

    targetYawAngle = Math.Acos(yawVector.Dot(Z_VECTOR)) * GetMultiplierSign(targetVector.GetDim(0));
    targetPitchAngle = Math.Acos(pitchVector.Dot(Z_VECTOR)) * GetMultiplierSign(targetVector.GetDim(1));

    //---------- PID Controller Adjustment ----------

    lastYawIntegral = lastYawIntegral + (targetYawAngle / 60);
    lastYawIntegral = (INTEGRAL_WINDUP_LIMIT &gt; 0 ? Math.Max(Math.Min(lastYawIntegral, INTEGRAL_WINDUP_LIMIT), -INTEGRAL_WINDUP_LIMIT) : lastYawIntegral);
    double yawDerivative = (targetYawAngle - lastYawError) * 60;
    lastYawError = targetYawAngle;
    targetYawAngle = (AIM_P * targetYawAngle) + (AIM_I * lastYawIntegral) + (AIM_D * yawDerivative);

    lastPitchIntegral = lastPitchIntegral + (targetPitchAngle / 60);
    lastPitchIntegral = (INTEGRAL_WINDUP_LIMIT &gt; 0 ? Math.Max(Math.Min(lastPitchIntegral, INTEGRAL_WINDUP_LIMIT), -INTEGRAL_WINDUP_LIMIT) : lastPitchIntegral);
    double pitchDerivative = (targetPitchAngle - lastPitchError) * 60;
    lastPitchError = targetPitchAngle;
    targetPitchAngle = (AIM_P * targetPitchAngle) + (AIM_I * lastPitchIntegral) + (AIM_D * pitchDerivative);

    if (Math.Abs(targetYawAngle) + Math.Abs(targetPitchAngle) &gt; AIM_LIMIT)
    {
        double adjust = AIM_LIMIT / (Math.Abs(targetYawAngle) + Math.Abs(targetPitchAngle));
        targetYawAngle *= adjust;
        targetPitchAngle *= adjust;
    }

    //---------- Set Gyroscope Parameters ----------

    SetGyroYaw(targetYawAngle);
    SetGyroPitch(targetPitchAngle);
}

void AimAtNaturalGravity()
{
    //---------- Activate Gyroscopes To Aim Dampener At Natural Gravity ----------

    if (refDownwardBlock == null || naturalGravityLength &lt; 0.01)
    {
        return;
    }

    MatrixD dampenerLookAtMatrix = MatrixD.CreateLookAt(POINT_ZERO, refDownwardBlock.WorldMatrix.Forward, (refForwardReverse ? refWorldMatrix.Backward : refWorldMatrix.Forward));

    Vector3D gravityVector = Vector3D.TransformNormal(naturalGravity, dampenerLookAtMatrix);
    gravityVector.SetDim(1, 0);
    gravityVector.Normalize();

    if (Double.IsNaN(gravityVector.Sum))
    {
        gravityVector = new Vector3D(Z_VECTOR);
    }

    targetRollAngle = Math.Acos(gravityVector.Dot(Z_VECTOR)) * GetMultiplierSign(gravityVector.GetDim(0));

    //---------- PID Controller Adjustment ----------

    lastRollIntegral = lastRollIntegral + (targetRollAngle / 60);
    lastRollIntegral = (INTEGRAL_WINDUP_LIMIT &gt; 0 ? Math.Max(Math.Min(lastRollIntegral, INTEGRAL_WINDUP_LIMIT), -INTEGRAL_WINDUP_LIMIT) : lastRollIntegral);
    double rollDerivative = (targetRollAngle - lastRollError) * 60;
    lastRollError = targetRollAngle;
    targetRollAngle = (AIM_P * targetRollAngle) + (AIM_I * lastRollIntegral) + (AIM_D * rollDerivative);

    //---------- Set Gyroscope Parameters ----------

    SetGyroRoll(targetRollAngle);
}

//------------------------------ Missile Separation Methods ------------------------------

bool DetachFromGrid()
{
    List&lt;IMyTerminalBlock&gt; blocks;
    IMyTerminalBlock detachBlock;

    switch (missileDetachPortType)
    {
        case 0:
        case 3:
            blocks = (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? GetBlocksWithName&lt;IMyShipMergeBlock&gt;(strDetachPort) : GetBlocksOfType&lt;IMyShipMergeBlock&gt;());
            detachBlock = GetClosestBlockFromReference(blocks, Me);

            if (detachBlock == null)
            {
                Echo("Error: Cannot find any Merge Block " + (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? "with name " + strDetachPort + " to detach" : "to detach."));
                return false;
            }

            detachBlockLocal = detachBlock;
            detachBlockRemote = GetConnectedMergeBlock(Me.CubeGrid, detachBlock) as IMyShipMergeBlock;

            if (detachBlockRemote == null)
            {
                Echo("Error: Merge Block to be detached is not properly connected to another Merge Block.");
                return false;
            }

            detachBlock.ApplyAction("OnOff_Off");
            return true;
        case 1:
        case 4:
            blocks = (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? GetBlocksWithName&lt;IMyMotorStator&gt;(strDetachPort) : GetBlocksOfType&lt;IMyMotorStator&gt;());
            detachBlock = GetClosestBlockFromReference(blocks, Me);

            if (detachBlock == null)
            {
                Echo("Error: Cannot find any Rotor " + (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? "with name " + strDetachPort + " to detach" : "to detach."));
                return false;
            }

            detachBlockLocal = Me;
            detachBlockRemote = detachBlock;

            detachBlock.ApplyAction("Detach");
            return true;
        case 2:
            blocks = (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? GetBlocksWithName&lt;IMyShipConnector&gt;(strDetachPort) : GetBlocksOfType&lt;IMyShipConnector&gt;());
            detachBlock = GetClosestBlockFromReference(blocks, Me, true);

            if (detachBlock == null)
            {
                Echo("Error: Cannot find any Connector " + (strDetachPort != null &amp;&amp; strDetachPort.Length &gt; 0 ? "with name " + strDetachPort + " to detach" : "to detach."));
                return false;
            }

            detachBlockLocal = detachBlock;
            detachBlockRemote = ((IMyShipConnector)detachBlock).OtherConnector;

            if (detachBlockRemote == null)
            {
                Echo("Error: Connector to be detached is not properly connected to another Connector.");
                return false;
            }

            detachBlock.ApplyAction("Unlock");
            return true;
        case 99:
            return true;
        default:
            Echo("Error: Unknown missileDetachPortType - " + missileDetachPortType + ".");
            return false;
    }
}

IMyTerminalBlock GetClosestBlockFromReference(List&lt;IMyTerminalBlock&gt; checkBlocks, IMyTerminalBlock referenceBlock, bool sameGridCheck = false)
{
    IMyTerminalBlock checkBlock = null;
    double prevCheckDistance = Double.MaxValue;

    for (int i = 0; i &lt; checkBlocks.Count; i++)
    {
        if (!sameGridCheck || checkBlocks[i].CubeGrid == referenceBlock.CubeGrid)
        {
            double currCheckDistance = (checkBlocks[i].GetPosition() - referenceBlock.GetPosition()).Length();
            if (currCheckDistance &lt; prevCheckDistance)
            {
                prevCheckDistance = currCheckDistance;
                checkBlock = checkBlocks[i];
            }
        }
    }

    return checkBlock;
}

IMyTerminalBlock GetConnectedMergeBlock(IMyCubeGrid grid, IMyTerminalBlock mergeBlock)
{
    IMySlimBlock slimBlock = grid.GetCubeBlock(mergeBlock.Position - new Vector3I(Base6Directions.GetVector(mergeBlock.Orientation.Left)));
    return (slimBlock == null ? null : slimBlock.FatBlock as IMyTerminalBlock);
}

void DetachLockedConnectors()
{
    List&lt;IMyTerminalBlock&gt; blocks = GetBlocksOfType&lt;IMyShipConnector&gt;();
    for (int i = 0; i &lt; blocks.Count; i++)
    {
        if (blocks[i].CubeGrid == Me.CubeGrid)
        {
            IMyShipConnector otherConnector = ((IMyShipConnector)blocks[i]).OtherConnector;
            if (otherConnector == null || blocks[i].CubeGrid != otherConnector.CubeGrid)
            {
                blocks[i].ApplyAction("Unlock");
            }
        }
    }
}

//------------------------------ Command Processing Methods ------------------------------

void ProcessConfigurationCommand(string commandLine)
{
    string[] keyValues = commandLine.Split(',');

    for (int i = 0; i &lt; keyValues.Length; i++)
    {
        string[] tokens = keyValues[i].Trim().Split(':');
        if (tokens.Length &gt; 0)
        {
            ProcessSingleConfigCommand(tokens);
        }
    }
}

void ProcessSingleConfigCommand(string[] tokens)
{
    string cmdToken = tokens[0].Trim();
    if (cmdToken.Equals("V_DVR") &amp;&amp; tokens.Length &gt;= 2)
    {
        double dvrValue;
        if (Double.TryParse(tokens[1], out dvrValue))
        {
            driftVectorReduction = dvrValue;
        }
    }
    else if (cmdToken.Equals("V_LS") &amp;&amp; tokens.Length &gt;= 2)
    {
        double lsValue;
        if (Double.TryParse(tokens[1], out lsValue))
        {
            launchSeconds = lsValue;
        }
    }
    else if (cmdToken.Equals("V_DRIFT") &amp;&amp; tokens.Length &gt;= 2)
    {
        bool driftValue;
        if (bool.TryParse(tokens[1], out driftValue))
        {
            boolDrift = driftValue;
        }
    }
    else if (cmdToken.Equals("V_LEAD") &amp;&amp; tokens.Length &gt;= 2)
    {
        bool leadValue;
        if (bool.TryParse(tokens[1], out leadValue))
        {
            boolLeadTarget = leadValue;
        }
    }
    else if (cmdToken.Equals("V_DAMP") &amp;&amp; tokens.Length &gt;= 2)
    {
        bool dampenerValue;
        if (bool.TryParse(tokens[1], out dampenerValue))
        {
            boolNaturalDampener = dampenerValue;
        }
    }
    else if (cmdToken.Equals("P_VT") &amp;&amp; tokens.Length &gt;= 2)
    {
        bool vtValue;
        if (bool.TryParse(tokens[1], out vtValue))
        {
            verticalTakeoff = vtValue;
        }
    }
    else if (cmdToken.Equals("SPIN") &amp;&amp; tokens.Length &gt;= 2)
    {
        double spinValue;
        if (Double.TryParse(tokens[1], out spinValue))
        {
            spinAmount = (int)spinValue;
        }
    }
}

//------------------------------ Initialization Methods ------------------------------

bool InitMissileBlocks()
{
    gyroscopes = GetGyroscopes();
    if (gyroscopes == null) return false;

    thrusters = GetThrusters();
    if (thrusters == null) return false;

    remoteControl = GetRemoteControl();
    if (remoteControl == null) return false;

    bool isFixedDirection = false;

    if (strDirectionRefBlock != null &amp;&amp; strDirectionRefBlock.Length &gt; 0)
    {
        refForwardBlock = GridTerminalSystem.GetBlockWithName(strDirectionRefBlock);
        isFixedDirection = (refForwardBlock != null);
    }

    if (spinAmount &gt; 0)
    {
        boolNaturalDampener = false;
    }

    if (refForwardBlock == null || boolNaturalDampener == null || boolDrift == null || verticalTakeoff)
    {
        thrustValues = ComputeMaxThrustValues(thrusters);
    }

    if (refForwardBlock == null)
    {
        refForwardBlock = ComputeHighestThrustReference(thrusters, thrustValues);
        refForwardReverse = true;
    }

    refWorldMatrix = refForwardBlock.WorldMatrix;
    if (refForwardReverse)
    {
        refWorldMatrix = MatrixD.CreateWorld(refWorldMatrix.Translation, refWorldMatrix.Backward, refWorldMatrix.Up);
    }

    InitGyrosAndThrusters(isFixedDirection);
    thrustValues = null;

    if (boolLeadTarget == null)
    {
        boolLeadTarget = true;
    }

    if (strLockOnSensor != null &amp;&amp; strLockOnSensor.Length &gt; 0)
    {
        List&lt;IMyTerminalBlock&gt; sensors = GetBlocksWithName&lt;IMySensorBlock&gt;(strLockOnSensor);
        if (sensors.Count &gt; 0)
        {
            lockOnSensor = sensors[0] as IMySensorBlock;
        }
    }

    if (strStatusDisplayPrefix != null &amp;&amp; strStatusDisplayPrefix.Length &gt; 0)
    {
        List&lt;IMyTerminalBlock&gt; blocks = GetBlocksWithPrefix&lt;IMyTerminalBlock&gt;(strStatusDisplayPrefix);
        if (blocks.Count &gt; 0)
        {
            statusDisplay = blocks[0];

            if (statusDisplay.HasAction("OnOff_On"))
            {
                statusDisplay.ApplyAction("OnOff_On");

                IMyRadioAntenna radioAntenna = statusDisplay as IMyRadioAntenna;
                if (radioAntenna != null &amp;&amp; !radioAntenna.IsBroadcasting)
                {
                    radioAntenna.ApplyAction("EnableBroadCast");
                }
            }
        }
    }

    return true;
}

void TurnOnBlocks(List&lt;IMyTerminalBlock&gt; blocks)
{
    for (int i = 0; i &lt; blocks.Count; i++)
    {
        blocks[i].ApplyAction("OnOff_On");
    }
}

List&lt;IMyTerminalBlock&gt; GetGyroscopes()
{
    List&lt;IMyTerminalBlock&gt; blocks = GetBlocksWithPrefix&lt;IMyGyro&gt;(strGyroscopesPrefix);
    if (blocks.Count &gt; 0)
    {
        return blocks;
    }

    GridTerminalSystem.GetBlocksOfType&lt;IMyGyro&gt;(blocks);
    if (blocks.Count &gt; 0)
    {
        return blocks;
    }
    else
    {
        Echo("Error: No Gyroscopes found.");
        return null;
    }
}

List&lt;IMyTerminalBlock&gt; GetThrusters()
{
    List&lt;IMyTerminalBlock&gt; blocks = GetBlocksWithPrefix&lt;IMyThrust&gt;(strThrustersPrefix);
    if (blocks.Count &gt; 0)
    {
        return blocks;
    }

    GridTerminalSystem.GetBlocksOfType&lt;IMyThrust&gt;(blocks);
    if (blocks.Count &gt; 0)
    {
        return blocks;
    }
    else
    {
        Echo("Error: No Thrusters found.");
        return null;
    }
}

IMyRemoteControl GetRemoteControl()
{
    List&lt;IMyTerminalBlock&gt; blocks = GetBlocksOfType&lt;IMyRemoteControl&gt;();
    IMyRemoteControl remoteBlock = (blocks.Count &gt; 0 ? blocks[0] as IMyRemoteControl : null);
    if (remoteBlock == null)
    {
        Echo("Error: No Remote Control found.");
    }
    return remoteBlock;
}

void InitGyrosAndThrusters(bool isFixedDirection)
{
    //---------- Find Gyroscope Orientation With Respect To Ship ----------

    gyroYawField = new string[gyroscopes.Count];
    gyroPitchField = new string[gyroscopes.Count];
    gyroYawFactor = new float[gyroscopes.Count];
    gyroPitchFactor = new float[gyroscopes.Count];
    gyroRollField = new string[gyroscopes.Count];
    gyroRollFactor = new float[gyroscopes.Count];

    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        Base6Directions.Direction gyroUp = gyroscopes[i].WorldMatrix.GetClosestDirection(refWorldMatrix.Up);
        Base6Directions.Direction gyroLeft = gyroscopes[i].WorldMatrix.GetClosestDirection(refWorldMatrix.Left);
        Base6Directions.Direction gyroForward = gyroscopes[i].WorldMatrix.GetClosestDirection(refWorldMatrix.Forward);

        switch (gyroUp)
        {
            case Base6Directions.Direction.Up:
                gyroYawField[i] = "Yaw";
                gyroYawFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Down:
                gyroYawField[i] = "Yaw";
                gyroYawFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Left:
                gyroYawField[i] = "Pitch";
                gyroYawFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Right:
                gyroYawField[i] = "Pitch";
                gyroYawFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Forward:
                gyroYawField[i] = "Roll";
                gyroYawFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Backward:
                gyroYawField[i] = "Roll";
                gyroYawFactor[i] = GYRO_FACTOR;
                break;
        }

        switch (gyroLeft)
        {
            case Base6Directions.Direction.Up:
                gyroPitchField[i] = "Yaw";
                gyroPitchFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Down:
                gyroPitchField[i] = "Yaw";
                gyroPitchFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Left:
                gyroPitchField[i] = "Pitch";
                gyroPitchFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Right:
                gyroPitchField[i] = "Pitch";
                gyroPitchFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Forward:
                gyroPitchField[i] = "Roll";
                gyroPitchFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Backward:
                gyroPitchField[i] = "Roll";
                gyroPitchFactor[i] = GYRO_FACTOR;
                break;
        }

        switch (gyroForward)
        {
            case Base6Directions.Direction.Up:
                gyroRollField[i] = "Yaw";
                gyroRollFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Down:
                gyroRollField[i] = "Yaw";
                gyroRollFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Left:
                gyroRollField[i] = "Pitch";
                gyroRollFactor[i] = GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Right:
                gyroRollField[i] = "Pitch";
                gyroRollFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Forward:
                gyroRollField[i] = "Roll";
                gyroRollFactor[i] = -GYRO_FACTOR;
                break;
            case Base6Directions.Direction.Backward:
                gyroRollField[i] = "Roll";
                gyroRollFactor[i] = GYRO_FACTOR;
                break;
        }

        gyroscopes[i].ApplyAction("OnOff_On");
    }

    //---------- Check Whether To Use Default PID Values ----------

    if (useDefaultPIDValues)
    {
        if (Me.CubeGrid.ToString().Contains("Large"))
        {
            AIM_P = DEF_BIG_GRID_P;
            AIM_I = DEF_BIG_GRID_I;
            AIM_D = DEF_BIG_GRID_D;
        }
        else
        {
            AIM_P = DEF_SMALL_GRID_P;
            AIM_I = DEF_SMALL_GRID_I;
            AIM_D = DEF_SMALL_GRID_D;
            AIM_LIMIT *= 2;
        }
    }

    //---------- Find Forward Thrusters ----------

    List&lt;IMyTerminalBlock&gt; checkThrusters = thrusters;
    thrusters = new List&lt;IMyTerminalBlock&gt;();

    if (!isFixedDirection || boolNaturalDampener == null || boolDrift == null || verticalTakeoff)
    {
        IMyTerminalBlock leftThruster = null;
        IMyTerminalBlock rightThruster = null;
        IMyTerminalBlock upThruster = null;
        IMyTerminalBlock downThruster = null;

        float leftThrustTotal = 0;
        float rightThrustTotal = 0;
        float upThrustTotal = 0;
        float downThrustTotal = 0;

        for (int i = 0; i &lt; checkThrusters.Count; i++)
        {
            Base6Directions.Direction thrusterDirection = refWorldMatrix.GetClosestDirection(checkThrusters[i].WorldMatrix.Backward);
            switch (thrusterDirection)
            {
                case Base6Directions.Direction.Forward:
                    thrusters.Add(checkThrusters[i]);
                    break;
                case Base6Directions.Direction.Left:
                    leftThruster = checkThrusters[i];
                    leftThrustTotal += thrustValues[i];
                    break;
                case Base6Directions.Direction.Right:
                    rightThruster = checkThrusters[i];
                    rightThrustTotal += thrustValues[i];
                    break;
                case Base6Directions.Direction.Up:
                    upThruster = checkThrusters[i];
                    upThrustTotal += thrustValues[i];
                    if (isFixedDirection)
                    {
                        refDownwardBlock = upThruster;
                    }
                    break;
                case Base6Directions.Direction.Down:
                    downThruster = checkThrusters[i];
                    downThrustTotal += thrustValues[i];
                    break;
            }

            checkThrusters[i].ApplyAction("OnOff_On");
        }

        float highestThrust = Math.Max(Math.Max(Math.Max(leftThrustTotal, rightThrustTotal), upThrustTotal), downThrustTotal);
        if (highestThrust == 0)
        {
            if (boolNaturalDampener == true)
            {
                Echo("Warning: Natural Gravity Dampener feature not possible as there are no Downward Thrusters found.");
            }
            boolNaturalDampener = false;

            if (boolDrift == null)
            {
                boolDrift = true;
            }
        }
        else
        {
            if (!isFixedDirection)
            {
                if (leftThrustTotal == highestThrust)
                {
                    refDownwardBlock = leftThruster;
                }
                else if (rightThrustTotal == highestThrust)
                {
                    refDownwardBlock = rightThruster;
                }
                else if (upThrustTotal == highestThrust)
                {
                    refDownwardBlock = upThruster;
                }
                else
                {
                    refDownwardBlock = downThruster;
                }
            }
            boolNaturalDampener = (refDownwardBlock != null);

            if (boolDrift == null)
            {
                float lowestThrust = Math.Min(Math.Min(Math.Min(leftThrustTotal, rightThrustTotal), upThrustTotal), downThrustTotal);
                boolDrift = (highestThrust &gt; lowestThrust * 2);
            }
        }

        if (verticalTakeoff &amp;&amp; refDownwardBlock != null)
        {
            launchThrusters = new List&lt;IMyTerminalBlock&gt;();

            for (int i = 0; i &lt; checkThrusters.Count; i++)
            {
                if (refDownwardBlock.WorldMatrix.Forward.Dot(checkThrusters[i].WorldMatrix.Forward) &gt;= 0.9)
                {
                    launchThrusters.Add(checkThrusters[i]);
                }
            }
        }
    }
    else
    {
        for (int i = 0; i &lt; checkThrusters.Count; i++)
        {
            Base6Directions.Direction thrusterDirection = refWorldMatrix.GetClosestDirection(checkThrusters[i].WorldMatrix.Backward);
            if (thrusterDirection == Base6Directions.Direction.Forward)
            {
                thrusters.Add(checkThrusters[i]);
            }
            else if (boolNaturalDampener == true &amp;&amp; thrusterDirection == Base6Directions.Direction.Up)
            {
                refDownwardBlock = checkThrusters[i];
            }

            checkThrusters[i].ApplyAction("OnOff_On");
        }

        if (boolNaturalDampener == true &amp;&amp; refDownwardBlock == null)
        {
            Echo("Warning: Natural Gravity Dampener feature not possible as there are no Downward Thrusters found.");
            boolNaturalDampener = false;
        }
    }
}

float[] ComputeMaxThrustValues(List&lt;IMyTerminalBlock&gt; checkThrusters)
{
    float[] thrustValues = new float[checkThrusters.Count];

    for (int i = 0; i &lt; checkThrusters.Count; i++)
    {
        float prevThrustOverride = checkThrusters[i].GetValueFloat("Override");
        checkThrusters[i].SetValueFloat("Override", checkThrusters[i].GetMaximum&lt;float&gt;("Override"));
        thrustValues[i] = ((IMyThrust)checkThrusters[i]).ThrustOverride;
        checkThrusters[i].SetValueFloat("Override", prevThrustOverride);
    }

    return thrustValues;
}

IMyTerminalBlock ComputeHighestThrustReference(List&lt;IMyTerminalBlock&gt; checkThrusters, float[] thrustValues)
{
    IMyTerminalBlock fwdThruster = null;
    IMyTerminalBlock bwdThruster = null;
    IMyTerminalBlock leftThruster = null;
    IMyTerminalBlock rightThruster = null;
    IMyTerminalBlock upThruster = null;
    IMyTerminalBlock downThruster = null;

    float fwdThrustTotal = 0;
    float bwdThrustTotal = 0;
    float leftThrustTotal = 0;
    float rightThrustTotal = 0;
    float upThrustTotal = 0;
    float downThrustTotal = 0;

    for (int i = 0; i &lt; checkThrusters.Count; i++)
    {
        Base6Directions.Direction thrusterDirection = Me.WorldMatrix.GetClosestDirection(checkThrusters[i].WorldMatrix.Backward);
        switch (thrusterDirection)
        {
            case Base6Directions.Direction.Forward:
                fwdThruster = checkThrusters[i];
                fwdThrustTotal += thrustValues[i];
                break;
            case Base6Directions.Direction.Backward:
                bwdThruster = checkThrusters[i];
                bwdThrustTotal += thrustValues[i];
                break;
            case Base6Directions.Direction.Left:
                leftThruster = checkThrusters[i];
                leftThrustTotal += thrustValues[i];
                break;
            case Base6Directions.Direction.Right:
                rightThruster = checkThrusters[i];
                rightThrustTotal += thrustValues[i];
                break;
            case Base6Directions.Direction.Up:
                upThruster = checkThrusters[i];
                upThrustTotal += thrustValues[i];
                break;
            case Base6Directions.Direction.Down:
                downThruster = checkThrusters[i];
                downThrustTotal += thrustValues[i];
                break;
        }
    }

    List&lt;IMyTerminalBlock&gt; highestThrustReferences = new List&lt;IMyTerminalBlock&gt;(2);

    float highestThrust = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(fwdThrustTotal, bwdThrustTotal), leftThrustTotal), rightThrustTotal), upThrustTotal), downThrustTotal);
    if (fwdThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(fwdThruster);
    }
    if (bwdThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(bwdThruster);
    }
    if (leftThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(leftThruster);
    }
    if (rightThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(rightThruster);
    }
    if (upThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(upThruster);
    }
    if (downThrustTotal == highestThrust)
    {
        highestThrustReferences.Add(downThruster);
    }

    if (highestThrustReferences.Count == 1)
    {
        return highestThrustReferences[0];
    }
    else
    {
        Vector3D diagonalVector = ComputeMissileDiagonalVector();

        IMyTerminalBlock closestToLengthRef = highestThrustReferences[0];
        double closestToLengthValue = 0;

        for (int i = 0; i &lt; highestThrustReferences.Count; i++)
        {
            double dotLength = Math.Abs(diagonalVector.Dot(highestThrustReferences[i].WorldMatrix.Forward));
            if (dotLength &gt; closestToLengthValue)
            {
                closestToLengthValue = dotLength;
                closestToLengthRef = highestThrustReferences[i];
            }
        }

        return closestToLengthRef;
    }
}

Vector3D ComputeMissileDiagonalVector()
{
    IMyCubeGrid cubeGrid = Me.CubeGrid;

    Vector3D minVector = cubeGrid.GridIntegerToWorld(cubeGrid.Min);
    Vector3D maxVector = cubeGrid.GridIntegerToWorld(cubeGrid.Max);

    return (minVector - maxVector);
}

//------------------------------ Thruster Control Methods ------------------------------

void FireThrusters(List&lt;IMyTerminalBlock&gt; listThrusters, bool overrideMode)
{
    if (listThrusters != null)
    {
        for (int i = 0; i &lt; listThrusters.Count; i++)
        {
            listThrusters[i].SetValue&lt;float&gt;("Override", (overrideMode ? listThrusters[i].GetMaximum&lt;float&gt;("Override") : 0f));
        }
    }
}

//------------------------------ Gyroscope Control Methods ------------------------------

void SetGyroOverride(bool bOverride)
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        if (((IMyGyro)gyroscopes[i]).GyroOverride != bOverride)
        {
            gyroscopes[i].ApplyAction("Override");
        }
    }
}

void SetGyroYaw(double yawRate)
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        gyroscopes[i].SetValueFloat(gyroYawField[i], (float)yawRate * gyroYawFactor[i]);
    }
}

void SetGyroPitch(double pitchRate)
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        gyroscopes[i].SetValueFloat(gyroPitchField[i], (float)pitchRate * gyroPitchFactor[i]);
    }
}

void SetGyroRoll(double rollRate)
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        gyroscopes[i].SetValueFloat(gyroRollField[i], (float)rollRate * gyroRollFactor[i]);
    }
}

void ZeroTurnGyro()
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        gyroscopes[i].SetValueFloat(gyroYawField[i], 0);
        gyroscopes[i].SetValueFloat(gyroPitchField[i], 0);
    }
}

void ResetGyro()
{
    for (int i = 0; i &lt; gyroscopes.Count; i++)
    {
        gyroscopes[i].SetValueFloat("Yaw", 0);
        gyroscopes[i].SetValueFloat("Pitch", 0);
        gyroscopes[i].SetValueFloat("Roll", 0);
    }
}

//------------------------------ Name Finder API ------------------------------

List&lt;IMyTerminalBlock&gt; GetBlocksOfType&lt;T&gt;() where T: class, IMyTerminalBlock
{
    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.GetBlocksOfType&lt;T&gt;(blocks);

    return blocks;
}

List&lt;IMyTerminalBlock&gt; GetBlocksWithName(string name)
{
    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.SearchBlocksOfName(name, blocks);

    return blocks;
}

List&lt;IMyTerminalBlock&gt; GetBlocksWithName&lt;T&gt;(string name) where T: class, IMyTerminalBlock
{
    nameMatcher = name;

    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.GetBlocksOfType&lt;T&gt;(blocks, MatchNameExact);

    return blocks;
}

List&lt;IMyTerminalBlock&gt; GetBlocksWithPrefix&lt;T&gt;(string name) where T: class, IMyTerminalBlock
{
    nameMatcher = name;

    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.GetBlocksOfType&lt;T&gt;(blocks, MatchNamePrefix);

    return blocks;
}

List&lt;IMyTerminalBlock&gt; GetBlocksWithSuffix&lt;T&gt;(string name) where T: class, IMyTerminalBlock
{
    nameMatcher = name;

    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.GetBlocksOfType&lt;T&gt;(blocks, MatchNameSuffix);

    return blocks;
}

List&lt;IMyTerminalBlock&gt; GetBlocksContaining&lt;T&gt;(string name) where T: class, IMyTerminalBlock
{
    nameMatcher = name;

    List&lt;IMyTerminalBlock&gt; blocks = new List&lt;IMyTerminalBlock&gt;();
    GridTerminalSystem.GetBlocksOfType&lt;T&gt;(blocks, MatchNameContaining);

    return blocks;
}

bool MatchNameExact(IMyTerminalBlock block)
{
    return block.CustomName.Equals(nameMatcher);
}

bool MatchNamePrefix(IMyTerminalBlock block)
{
    return block.CustomName.StartsWith(nameMatcher);
}

bool MatchNameSuffix(IMyTerminalBlock block)
{
    return block.CustomName.EndsWith(nameMatcher);
}

bool MatchNameContaining(IMyTerminalBlock block)
{
    return block.CustomName.Contains(nameMatcher);
}</Program>
              <Storage />
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>94958453805792704</EntityId>
              <Min x="-1" y="2" z="3" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>122094648029355490</EntityId>
              <Min x="-1" y="2" z="4" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>112983238490245134</EntityId>
              <Min x="-1" y="2" z="5" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>LargeBlockSmallThrust</SubtypeName>
              <EntityId>124621947687747455</EntityId>
              <Min x="0" y="2" z="5" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
              <CustomName>Small Ion Thruster 1</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Thrust">
              <SubtypeName>LargeBlockSmallThrust</SubtypeName>
              <EntityId>135699132254320200</EntityId>
              <Min x="0" y="3" z="5" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
              <CustomName>Small Ion Thruster 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_BatteryBlock">
              <SubtypeName>LargeBlockBatteryBlock</SubtypeName>
              <EntityId>135873438403323780</EntityId>
              <Min x="0" y="3" z="2" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <CurrentStoredPower>3</CurrentStoredPower>
              <ProducerEnabled>true</ProducerEnabled>
              <MaxStoredPower>0</MaxStoredPower>
              <SemiautoEnabled>false</SemiautoEnabled>
              <OnlyDischargeEnabled>false</OnlyDischargeEnabled>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Gyro">
              <SubtypeName>LargeBlockGyro</SubtypeName>
              <EntityId>142901299410482819</EntityId>
              <Min x="0" y="3" z="3" />
              <BlockOrientation Forward="Down" Up="Backward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <GyroPower>0.5014789</GyroPower>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Base</SubtypeName>
              <Min x="0" y="3" z="1" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>123854727668255020</EntityId>
              <Min x="1" y="2" z="5" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>120579503749823330</EntityId>
              <Min x="1" y="2" z="4" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>75561693599484645</EntityId>
              <Min x="1" y="2" z="3" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>94352882178448476</EntityId>
              <Min x="0" y="1" z="5" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>128049868712378107</EntityId>
              <Min x="0" y="1" z="4" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>134099207064341806</EntityId>
              <Min x="0" y="1" z="3" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>100549308366935818</EntityId>
              <Min x="0" y="1" z="2" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>121719499259487293</EntityId>
              <Min x="0" y="1" z="1" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_SensorBlock">
              <SubtypeName>LargeBlockSensor</SubtypeName>
              <EntityId>92414224734394923</EntityId>
              <Min x="0" y="2" z="0" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <CustomName>Sensor Detonate</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>true</ShowInTerminal>
              <ShowInToolbarConfig>true</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <FieldMin x="-15" y="-15" z="-25" />
              <FieldMax x="15" y="15" z="1" />
              <Toolbar>
                <ToolbarType>Character</ToolbarType>
                <SelectedSlot xsi:nil="true" />
                <Slots>
                  <Slot>
                    <Index>0</Index>
                    <Item />
                    <Data xsi:type="MyObjectBuilder_ToolbarItemTerminalGroup">
                      <Action>Detonate</Action>
                      <GridEntityId>0</GridEntityId>
                      <BlockEntityId>92414224734394923</BlockEntityId>
                      <GroupName>WH</GroupName>
                    </Data>
                  </Slot>
                </Slots>
              </Toolbar>
              <PlaySound>false</PlaySound>
              <DetectPlayers>true</DetectPlayers>
              <DetectFloatingObjects>false</DetectFloatingObjects>
              <DetectSmallShips>true</DetectSmallShips>
              <DetectLargeShips>true</DetectLargeShips>
              <DetectStations>true</DetectStations>
              <DetectSubgrids>false</DetectSubgrids>
              <IsActive>false</IsActive>
              <DetectAsteroids>true</DetectAsteroids>
              <DetectOwner>false</DetectOwner>
              <DetectFriendly>false</DetectFriendly>
              <DetectNeutral>true</DetectNeutral>
              <DetectEnemy>true</DetectEnemy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="1" y="2" z="2" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="-1" y="2" z="2" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="1" y="1" z="2" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="-1" y="1" z="2" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="1" y="3" z="5" />
              <BlockOrientation Forward="Left" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="-1" y="3" z="5" />
              <BlockOrientation Forward="Right" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="1" y="4" z="5" />
              <BlockOrientation Forward="Right" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeBlockArmorSlope2Tip</SubtypeName>
              <Min x="-1" y="4" z="5" />
              <BlockOrientation Forward="Left" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_Warhead">
              <SubtypeName>LargeWarhead</SubtypeName>
              <EntityId>91017261826121476</EntityId>
              <Min x="0" y="3" z="4" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <Owner>144115188075855873</Owner>
              <BuiltBy>144115188075855873</BuiltBy>
              <ShareMode>Faction</ShareMode>
              <CustomName>Warhead 2</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <CountdownMs>1233</CountdownMs>
              <IsArmed>true</IsArmed>
              <IsCountingDown>false</IsCountingDown>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x1Side</SubtypeName>
              <EntityId>110655494904850175</EntityId>
              <Min x="-1" y="3" z="4" />
              <BlockOrientation Forward="Backward" Up="Up" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x1Side</SubtypeName>
              <EntityId>90470368080128408</EntityId>
              <Min x="1" y="3" z="4" />
              <BlockOrientation Forward="Up" Up="Backward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>135794006390378396</EntityId>
              <Min x="0" y="4" z="4" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>72547593706186255</EntityId>
              <Min x="1" y="3" z="3" />
              <BlockOrientation Forward="Forward" Up="Right" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>114443971691521889</EntityId>
              <Min x="-1" y="3" z="3" />
              <BlockOrientation Forward="Forward" Up="Left" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>LargeSteelCatwalkPlate</SubtypeName>
              <EntityId>118851936330234384</EntityId>
              <Min x="0" y="4" z="3" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x1Side</SubtypeName>
              <EntityId>73282261667795934</EntityId>
              <Min x="1" y="2" z="1" />
              <BlockOrientation Forward="Down" Up="Forward" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x1Side</SubtypeName>
              <EntityId>79826699982374851</EntityId>
              <Min x="-1" y="2" z="1" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_InteriorLight">
              <SubtypeName>SmallLight</SubtypeName>
              <EntityId>112494396182051687</EntityId>
              <Min x="0" y="3" z="0" />
              <BlockOrientation Forward="Forward" Up="Down" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
              <CustomName>Homing Indicator</CustomName>
              <ShowOnHUD>false</ShowOnHUD>
              <ShowInTerminal>false</ShowInTerminal>
              <ShowInToolbarConfig>false</ShowInToolbarConfig>
              <ShowInInventory>true</ShowInInventory>
              <Enabled>true</Enabled>
              <Radius>1</Radius>
              <ReflectorRadius>120</ReflectorRadius>
              <ColorGreen>0</ColorGreen>
              <ColorBlue>0</ColorBlue>
              <Falloff>1.9515177</Falloff>
              <Intensity>3.002605</Intensity>
              <BlinkIntervalSeconds>1</BlinkIntervalSeconds>
              <BlinkLenght>5</BlinkLenght>
              <BlinkOffset>0</BlinkOffset>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x2SideRight</SubtypeName>
              <EntityId>108944672421411833</EntityId>
              <Min x="1" y="3" z="1" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
            <MyObjectBuilder_CubeBlock xsi:type="MyObjectBuilder_CubeBlock">
              <SubtypeName>Window1x2SideLeft</SubtypeName>
              <EntityId>75675751026889215</EntityId>
              <Min x="-1" y="3" z="1" />
              <ColorMaskHSV x="0.558333337" y="-0.69" z="-0.42" />
              <BuiltBy>144115188075855873</BuiltBy>
            </MyObjectBuilder_CubeBlock>
          </CubeBlocks>
          <XMirroxPlane x="0" y="2" z="2" />
          <BlockGroups>
            <MyObjectBuilder_BlockGroup>
              <Name>WH</Name>
              <Blocks>
                <Vector3I>
                  <X>0</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3I>
                <Vector3I>
                  <X>0</X>
                  <Y>3</Y>
                  <Z>4</Z>
                </Vector3I>
              </Blocks>
            </MyObjectBuilder_BlockGroup>
          </BlockGroups>
          <DisplayName>Long Range Torpedo</DisplayName>
          <DestructibleBlocks>true</DestructibleBlocks>
          <IsRespawnGrid>false</IsRespawnGrid>
          <LocalCoordSys>11</LocalCoordSys>
        </CubeGrid>
      </CubeGrids>
    </Prefab>
  </Prefabs>
</Definitions>